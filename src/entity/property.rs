/*!

Properties are marker types associated with entities. A property marker type (like `Age`)
identifies a property and its value type (like `u8`). Properties are declared with
`define_property!` and associated with entities through `define_entity!`.

The `PropertyDef` trait should be implemented only with one of the macros `define_entity!`,
`impl_property!`, `define_derived_property!`, `impl_derived_property!`, or `define_multi_property!`
to ensure correct and consistent implementation.

*/

use std::any::TypeId;
use std::fmt::Debug;
use std::marker::PhantomData;

use serde::Serialize;

use crate::entity::property_store::get_property_dependents_static;
use crate::entity::{Entity, EntityId};
use crate::hashing::hash_serialized_128;
use crate::{Context, HashSet};

/// The kind of initialization that a property has.
#[derive(Copy, Clone, Eq, PartialEq, Debug)]
pub enum PropertyInitializationKind {
    /// The property is not derived and has no initial value. Its initialization is _explicit_, meaning it must be set
    /// by client code at time of creation. Initialization is _explicit_ if and only if the property is _required_,
    /// that is, if a value for the property must be supplied at time of entity creation.
    Explicit,

    /// The property is a derived property (it's value is computed dynamically from other property values). It cannot
    /// be set explicitly.
    Derived,

    /// The property is given a constant initial value. Its initialization does not
    /// trigger a change event.
    Constant,
}

/// A type-erased interface for property values.
pub trait AnyProperty: Copy + Debug + PartialEq + Serialize + 'static {}
impl<T> AnyProperty for T where T: Copy + Debug + PartialEq + Serialize + 'static {}

/// Base trait for property markers. Generated by `define_property!`.
///
/// This trait identifies a property and its value type without tying it to any entity.
/// Entity association is done separately via `PropertyDef<E>` (generated by `define_entity!`).
pub trait IsProperty: Copy + 'static {
    type Value: AnyProperty;
}

/// ZST marker for non-primitive property types (enums, structs).
/// Used in `get_property`: `context.get_property(entity, Property::<InfectionStatus>::new())`
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Property<T>(PhantomData<T>);

impl<T> Property<T> {
    pub const fn new() -> Self {
        Self(PhantomData)
    }
}

impl<T> Default for Property<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: AnyProperty> IsProperty for Property<T> {
    type Value = T;
}

// Property<T> needs Serialize to satisfy AnyProperty-like bounds used in some contexts
impl<T> Serialize for Property<T> {
    fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        serializer.serialize_unit()
    }
}

/// Trait for `set_property` argument and query filters.
///
/// Implemented for `(Marker, Value)` tuples (e.g., `(Age, 30_u8)`) and
/// for enum property values directly (e.g., `InfectionStatus::Infected`).
pub trait PropertySetter<E: Entity> {
    type Def: PropertyDef<E>;
    fn into_value(self) -> <Self::Def as PropertyDef<E>>::Value;
}

/// Blanket impl for `(Marker, Value)` tuples where the marker implements `PropertyDef<E>`.
impl<E: Entity, P: PropertyDef<E>> PropertySetter<E> for (P, P::Value)
where
    P: Copy,
{
    type Def = P;
    fn into_value(self) -> P::Value {
        self.1
    }
}

/// The full property definition trait tying a property marker to a specific entity.
///
/// Generated by `define_entity!` for new-style properties, or by `impl_property!` for
/// legacy wrapper types. All properties must implement this trait using one of the
/// property-defining macros.
pub trait PropertyDef<E: Entity>: AnyProperty {
    /// The underlying value type for this property.
    type Value: AnyProperty;

    /// Some properties might store a transformed version of the value in the index. This is the
    /// type of the transformed value. For simple properties this will be the same as `Self`.
    type CanonicalValue: AnyProperty;

    fn name() -> &'static str {
        let full = std::any::type_name::<Self>();
        full.rsplit("::").next().unwrap()
    }

    /// The kind of initialization this property has.
    #[must_use]
    fn initialization_kind() -> PropertyInitializationKind;

    #[must_use]
    #[inline]
    fn is_derived() -> bool {
        Self::initialization_kind() == PropertyInitializationKind::Derived
    }

    #[must_use]
    #[inline]
    fn is_required() -> bool {
        Self::initialization_kind() == PropertyInitializationKind::Explicit
    }

    /// Compute the value of the property, possibly by accessing the context and using the entity's ID.
    #[must_use]
    fn compute_derived(context: &Context, entity_id: EntityId<E>) -> Self::Value;

    /// Return the default initial constant value.
    #[must_use]
    fn default_const() -> Self::Value;

    /// This transforms a value into a `Self::CanonicalValue`, e.g., for storage in an index.
    /// For simple properties, this is the identity function.
    #[must_use]
    fn make_canonical(value: Self::Value) -> Self::CanonicalValue;

    /// The inverse transform of `make_canonical`. For simple properties, this is the identity function.
    #[must_use]
    fn make_uncanonical(value: Self::CanonicalValue) -> Self::Value;

    /// Returns a string representation of the property value, e.g. for writing to a CSV file.
    #[must_use]
    fn get_display(value: &Self::Value) -> String;

    /// For cases when the property's hash needs to be computed in a special way.
    #[must_use]
    fn hash_property_value(value: &Self::CanonicalValue) -> u128 {
        hash_serialized_128(value)
    }

    /// Overridden by multi-properties, which use the `TypeId` of the ordered tuple so that tuples
    /// with the same component types in a different order will have the same type ID.
    #[must_use]
    fn type_id() -> TypeId {
        TypeId::of::<Self>()
    }

    /// For implementing the registry pattern
    fn id() -> usize;

    /// For properties that use the index of some other property, e.g. multi-properties, this
    /// method gives the ID of the property index to use.
    ///
    /// Note that this is independent of whether or not the property actually is being indexed,
    /// which is a property of the `Context` instance, not of the `PropertyDef<E>` type itself.
    fn index_id() -> usize {
        Self::id()
    }

    /// Returns a vector of transitive non-derived dependencies. If the property is not derived, the
    /// Vec will be empty. The dependencies are represented by their `PropertyDef<E>::index()` value.
    ///
    /// This function is only used to construct the static dependency graph
    /// within property `ctor`s, after which time the dependents of a property
    /// are accessible through `PropertyDef<E>::dependents()` as a `&'static [usize]`.
    fn non_derived_dependencies() -> Vec<usize> {
        let mut result = HashSet::default();
        Self::collect_non_derived_dependencies(&mut result);
        result.into_iter().collect()
    }

    /// An auxiliary helper for `non_derived_dependencies` above.
    fn collect_non_derived_dependencies(result: &mut HashSet<usize>);

    /// Get a list of derived properties that depend on this property. The properties are
    /// represented by their `PropertyDef::index()`. The list is pre-computed in `ctor`s.
    fn dependents() -> &'static [usize] {
        get_property_dependents_static::<E>(Self::id())
    }
}
